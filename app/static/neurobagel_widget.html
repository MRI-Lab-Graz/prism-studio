<!-- NeuroBagel Annotation Widget -->
<div id="neurobagelAnnotationWidget">
  <style>
    .neurobagel-widget {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 15px;
      max-height: 600px;
      overflow-y: auto;
    }
    
    .nb-sidebar {
      flex: 0 0 220px;
      border-right: 1px solid #dee2e6;
      padding-right: 15px;
      max-height: 550px;
      overflow-y: auto;
    }
    
    .nb-main {
      flex: 1;
      min-height: 400px;
    }
    
    .nb-section-title {
      font-weight: 600;
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      margin: 15px 0 8px 0;
      padding-bottom: 8px;
      border-bottom: 1px solid #e0e0e0;
    }
    
    .nb-column-item {
      padding: 8px 10px;
      margin: 4px 0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      border-left: 3px solid transparent;
      transition: all 0.2s ease;
    }
    
    .nb-column-item:hover {
      background: #e7f1ff;
      border-left-color: #0d6efd;
    }
    
    .nb-column-item.active {
      background: #0d6efd;
      color: white;
      border-left-color: #0d6efd;
      font-weight: 600;
    }
    
    .nb-column-item-type {
      font-size: 11px;
      opacity: 0.7;
      margin-left: 4px;
    }
    
    .nb-editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 12px;
      border-bottom: 2px solid #dee2e6;
    }
    
    .nb-editor-title {
      font-size: 16px;
      font-weight: 600;
    }
    
    .nb-editor-type-badge {
      background: #0d6efd;
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }
    
    .nb-field-group {
      margin-bottom: 20px;
    }
    
    .nb-field-label {
      font-weight: 600;
      font-size: 12px;
      color: #212529;
      margin-bottom: 6px;
      text-transform: uppercase;
    }
    
    .nb-field-description {
      font-size: 13px;
      color: #666;
      margin-bottom: 10px;
      padding: 8px;
      background: white;
      border-left: 3px solid #0d6efd;
      border-radius: 2px;
    }
    
    .nb-value-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .nb-value-item {
      padding: 10px;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .nb-value-item:hover {
      border-color: #0d6efd;
      background: #f0f6ff;
    }
    
    .nb-value-item.selected {
      border-color: #0d6efd;
      background: #e7f1ff;
    }
    
    .nb-value-header {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 4px;
    }
    
    .nb-value-label {
      color: #666;
      font-size: 12px;
      margin-bottom: 3px;
    }
    
    .nb-value-uri {
      font-size: 11px;
      color: #999;
      font-family: monospace;
      word-break: break-all;
    }
    
    .nb-button-group {
      display: flex;
      gap: 8px;
      margin-top: 15px;
    }
    
    .nb-btn {
      padding: 8px 12px;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    
    .nb-btn:hover {
      background: #e7f1ff;
      border-color: #0d6efd;
    }
    
    .nb-btn-primary {
      background: #0d6efd;
      color: white;
      border-color: #0d6efd;
    }
    
    .nb-btn-primary:hover {
      background: #0b5ed7;
    }
    
    .nb-empty-state {
      padding: 40px 20px;
      text-align: center;
      color: #999;
    }
    
    .nb-toggle-btn {
      padding: 6px 12px;
      background: #0d6efd;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
    }
    
    .nb-toggle-btn:hover {
      background: #0b5ed7;
    }
  </style>

  <div style="margin-bottom: 10px; display: flex; gap: 8px;">
    <button class="nb-toggle-btn" onclick="window.toggleNeurobagelWidget()">
      üìù Show/Hide Quick Editor
    </button>
    <button class="nb-btn" onclick="window.autoMatchNeurobagelConcepts()" style="background: #eef7ff; color: #0056b3; border-color: #cce5ff;">
      <i class="fas fa-magic me-1"></i>Auto-Match Concepts
    </button>
  </div>

  <div class="neurobagel-widget" id="neurobagelWidgetContent" style="display: none;">
    <!-- Sidebar -->
    <div class="nb-sidebar">
      <div class="nb-section-title">Standardized Variables</div>
      <div id="neurobagelSidebar"></div>
      
      <div class="nb-section-title" style="margin-top: 20px;">Unannotated</div>
      <div id="neurobagelUnannotated"></div>
    </div>
    
    <!-- Main Editor -->
    <div class="nb-main">
      <div id="neurobagelEditor">
        <div class="nb-empty-state">
          <p>Select a column from the sidebar to annotate</p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// NeuroBagel Annotation Widget Functions
window.neurobagelWidgetState = {
  allColumns: {},
  selectedColumn: null,
  expanded: false
};

// Semantic enrichment common mappings
window.neurobagelCommonMappings = {
  "Sex": {
    "standardized_variable": "biological_sex",
    "term_url": "nb:Sex",
    "data_type": "categorical",
    "description": "Biological sex of the participant.",
    "levels": {
      "M": { "label": "Male", "uri": "snomed:248153007" },
      "F": { "label": "Female", "uri": "snomed:248152002" },
      "O": { "label": "Other", "uri": "snomed:447964000" }
    }
  },
  "Age": {
    "standardized_variable": "age",
    "term_url": "nb:Age",
    "data_type": "continuous",
    "unit": "years",
    "description": "Age of the participant at the time of session (usually in years)."
  },
  "Handedness": {
    "standardized_variable": "handedness",
    "term_url": "nb:Handedness",
    "data_type": "categorical",
    "description": "Handedness of the participant.",
    "levels": {
      "L": { "label": "Left", "uri": "snomed:87622008" },
      "R": { "label": "Right", "uri": "snomed:78791000" },
      "A": { "label": "Ambidextrous", "uri": "snomed:16022009" }
    }
  },
  "Diagnosis": {
    "standardized_variable": "diagnosis",
    "term_url": "nb:Diagnosis",
    "data_type": "categorical",
    "description": "Clinical diagnosis or study group classification.",
    "levels": {
      "CTRL": { "label": "Healthy Control", "uri": "ncit:C94342" },
      "HC": { "label": "Healthy Control", "uri": "ncit:C94342" },
      "CONTROL": { "label": "Healthy Control", "uri": "ncit:C94342" },
      "PAT": { "label": "Patient", "uri": "ncit:C16960" },
      "PATIENT": { "label": "Patient", "uri": "ncit:C16960" },
      "ADHD": { "label": "ADHD", "uri": "snomed:406506008" },
      "ASD": { "label": "Autism Spectrum Disorder", "uri": "snomed:408856003" },
      "MDD": { "label": "Major Depressive Disorder", "uri": "snomed:370143000" },
      "SZ": { "label": "Schizophrenia", "uri": "snomed:58214004" },
      "SCZ": { "label": "Schizophrenia", "uri": "snomed:58214004" },
      "BD": { "label": "Bipolar Disorder", "uri": "snomed:13746004" },
      "PD": { "label": "Parkinson's Disease", "uri": "snomed:49049000" },
      "AD": { "label": "Alzheimer's Disease", "uri": "snomed:26929004" },
      "MCI": { "label": "Mild Cognitive Impairment", "uri": "snomed:386806002" },
      "OCD": { "label": "Obsessive-Compulsive Disorder", "uri": "snomed:191736004" },
      "PTSD": { "label": "Post-Traumatic Stress Disorder", "uri": "snomed:47505003" },
      "GAD": { "label": "Generalized Anxiety Disorder", "uri": "snomed:21897009" }
    }
  },
  "Education": {
    "standardized_variable": "education_level",
    "term_url": "nb:EducationLevel",
    "data_type": "categorical",
    "description": "Highest level of education completed.",
    "levels": {
      "1": { "label": "Less than High School", "uri": "ncit:C17781" },
      "2": { "label": "High School Diploma", "uri": "ncit:C17782" },
      "3": { "label": "Some College", "uri": "ncit:C17783" },
      "4": { "label": "Bachelor's Degree", "uri": "ncit:C17784" },
      "5": { "label": "Graduate Degree", "uri": "ncit:C17785" }
    }
  },
  "Assessment": {
    "standardized_variable": "assessment",
    "term_url": "nb:Assessment",
    "description": "Score or observation from a standardized assessment tool."
  },
  "ParticipantID": {
    "standardized_variable": "participant_id",
    "term_url": "nb:ParticipantID",
    "data_type": "text",
    "description": "Unique identifier for the participant."
  },
  "SessionID": {
    "standardized_variable": "session_id",
    "term_url": "nb:SessionID",
    "data_type": "text",
    "description": "Unique identifier for the study session."
  }
};

window.applyNeurobagelEnrichment = function(colName) {
  const concept = document.getElementById(`nb-map-${colName}`).value;
  if (!concept) return;
  
  const mapping = window.neurobagelCommonMappings[concept];
  if (!mapping) return;
  
  const colData = window.neurobagelWidgetState.allColumns[colName];
  
  // Apply the enrichment
  colData.standardized_variable = mapping.standardized_variable;
  colData.term_url = mapping.term_url;
  colData.label = concept;
  if (mapping.data_type) colData.data_type = mapping.data_type;
  if (mapping.description && !colData.description) colData.description = mapping.description;
  if (mapping.unit) colData.unit = mapping.unit;
  
  // For categorical, try to match existing level keys
  if (mapping.levels && colData.levels) {
    for (const [key, mappingLevel] of Object.entries(mapping.levels)) {
      // Direct match
      if (colData.levels[key]) {
        colData.levels[key].label = mappingLevel.label;
        colData.levels[key].uri = mappingLevel.uri;
      } else {
        // Case-insensitive match or label match
        const existingKey = Object.keys(colData.levels).find(k => 
          k.toLowerCase() === key.toLowerCase() || 
          (colData.levels[k].label && colData.levels[k].label.toLowerCase() === mappingLevel.label.toLowerCase())
        );
        if (existingKey) {
          colData.levels[existingKey].label = mappingLevel.label;
          colData.levels[existingKey].uri = mappingLevel.uri;
        }
      }
    }
  }
  
  console.log(`‚úÖ Applied ${concept} enrichment to ${colName}`);
  window.renderNeurobagelEditor(colName, colData);
  
  // Re-render widget sidebar to update variable categorization
  window.renderNeurobagelWidget();
};

window.autoMatchNeurobagelConcepts = function() {
  const allColumns = window.neurobagelWidgetState.allColumns;
  let matches = 0;
  
  for (const [colName, colData] of Object.entries(allColumns)) {
    const lowerName = colName.toLowerCase();
    let bestMatch = null;
    
    // Fuzzy match logic
    if (lowerName === 'sex' || lowerName === 'gender') bestMatch = 'Sex';
    else if (lowerName === 'age' || lowerName === 'years') bestMatch = 'Age';
    else if (lowerName === 'handedness' || lowerName === 'hand') bestMatch = 'Handedness';
    else if (lowerName === 'education' || lowerName === 'education_level' || lowerName === 'edu') bestMatch = 'Education';
    else if (lowerName === 'group' || lowerName === 'diagnosis' || lowerName === 'dx' || lowerName === 'pheno_group') bestMatch = 'Diagnosis';
    else if (lowerName === 'participant_id' || lowerName === 'subject_id' || lowerName === 'id') bestMatch = 'ParticipantID';
    else if (lowerName === 'session_id' || lowerName === 'session') bestMatch = 'SessionID';
    
    if (bestMatch && !colData.standardized_variable) {
      const mapping = window.neurobagelCommonMappings[bestMatch];
      colData.standardized_variable = mapping.standardized_variable;
      colData.term_url = mapping.term_url;
      colData.label = bestMatch;
      if (mapping.data_type) colData.data_type = mapping.data_type;
      if (mapping.levels && colData.levels) {
          // Quick level match
          for (const [k, v] of Object.entries(mapping.levels)) {
              if (colData.levels[k]) {
                  colData.levels[k].label = v.label;
                  colData.levels[k].uri = v.uri;
              }
          }
      }
      matches++;
    }
  }
  
  if (matches > 0) {
    alert(`Auto-matched ${matches} concepts!`);
    window.renderNeurobagelWidget();
  } else {
    alert("No obvious matches found based on column names.");
  }
};

window.toggleNeurobagelWidget = function() {
  const widget = document.getElementById('neurobagelAnnotationWidget');
  const content = document.getElementById('neurobagelWidgetContent');
  const expanded = window.neurobagelWidgetState.expanded;
  
  window.neurobagelWidgetState.expanded = !expanded;
  content.style.display = expanded ? 'none' : 'flex';
};

// Auto-detect data type for custom columns based on TSV values
window.autoDetectDataType = function(colName, uniqueValues) {
  if (!uniqueValues || uniqueValues.length === 0) {
    return 'text';
  }

  // Rule 0: Date/time-like columns should be text (not categorical)
  const lowerName = String(colName || '').toLowerCase();
  const hasDateNameHint = ['date', 'time', 'timestamp', 'datetime'].some(token => lowerName.includes(token));
  const dateLikeRegex = /^(\d{1,2}[./-]\d{1,2}[./-]\d{2,4}|\d{4}[./-]\d{1,2}[./-]\d{1,2})(\s+\d{1,2}:\d{2}(:\d{2})?)?$/;
  const dateLikeCount = uniqueValues.filter(v => {
    const s = String(v ?? '').trim();
    if (!s) return false;
    if (dateLikeRegex.test(s)) return true;
    const parsed = Date.parse(s);
    return !Number.isNaN(parsed);
  }).length;
  if (hasDateNameHint || (dateLikeCount / uniqueValues.length) > 0.6) {
    return 'text';
  }
  
  // Rule 1: If <= 10 unique values, treat as categorical
  if (uniqueValues.length <= 10) {
    // Additional check: make sure they're not all numbers with different values
    const allNumeric = uniqueValues.every(v => !isNaN(v) && v !== '');
    if (allNumeric) {
      // If all numeric and > 5 unique values, could be continuous
      // But if they look like IDs or codes, keep as categorical
      const numericValues = uniqueValues.map(Number).sort((a, b) => a - b);
      const range = numericValues[numericValues.length - 1] - numericValues[0];
      const step = range > 0 ? range / (numericValues.length - 1) : 0;
      
      // If values are evenly spaced (like ages: 20, 21, 22...), likely continuous
      // If they're sparse or with gaps, likely codes/categories
      const isEvenlySpaced = numericValues.every((val, idx, arr) => {
        if (idx === 0) return true;
        const expectedDiff = step;
        const actualDiff = val - arr[idx - 1];
        return Math.abs(actualDiff - expectedDiff) < 1;
      });
      
      if (isEvenlySpaced && range > 5) {
        return 'continuous';
      }
    }
    
    return 'categorical';
  }
  
  // Rule 2: If > 10 unique values, likely continuous or text
  // Check if mostly numeric
  const numericCount = uniqueValues.filter(v => !isNaN(v) && v !== '').length;
  if (numericCount / uniqueValues.length > 0.8) {
    return 'continuous';
  }
  
  return 'text';
};

// Fetch NeuroBagel participants dictionary from API
window.fetchNeurobagelParticipants = async function() {
  console.log('üì° Fetching NeuroBagel participants data...');
  try {
    const response = await fetch('/api/neurobagel/participants');
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const data = await response.json();
    console.log('‚úÖ Successfully fetched NeuroBagel data');
    return data;
  } catch (error) {
    console.error('‚ùå Failed to fetch NeuroBagel data:', error);
    // Return empty structure to allow widget to continue
    return { properties: {} };
  }
};

window.renderNeurobagelWidget = async function() {
  console.log('üß† renderNeurobagelWidget called');
  const data = await window.fetchNeurobagelParticipants();
  console.log('üß† Fetched data:', data);
  if (!data || !data.properties) {
    console.warn('‚ùå No NeuroBagel data for widget');
    return;
  }
  console.log('‚úÖ Data has properties:', Object.keys(data.properties).length, 'columns');
  
  // Merge TSV unique values with NeuroBagel data for categorical columns
  const enrichedData = data.properties;
  if (window.participantsTsvData) {
    console.log('üîÑ Merging TSV unique values with NeuroBagel data');
    for (const [colName, colData] of Object.entries(enrichedData)) {
      if (colData.data_type === 'categorical' && window.participantsTsvData[colName]) {
        const uniqueValues = window.participantsTsvData[colName];
        console.log(`üìä Column ${colName} - TSV values:`, uniqueValues);
        
        // If backend already provided enriched levels (with SNOMED codes), preserve them
        // Only add missing TSV values that aren't already defined
        if (!colData.levels) {
          colData.levels = {};
        }
        
        // Add TSV values as levels, but PRESERVE existing enriched data from backend
        uniqueValues.forEach(value => {
          if (!colData.levels[value]) {
            // Only add if not already enriched by backend
            colData.levels[value] = {
              label: value,
              description: '',
              uri: null
            };
          }
          // If already exists from backend, keep it (it has SNOMED codes!)
        });
        
        console.log(`‚úÖ Merged ${colName} with ${Object.keys(colData.levels).length} categorical levels (${uniqueValues.length} from TSV)`);
      }
    }
    
    // Auto-detect data types for custom columns in TSV (not in NeuroBagel)
    for (const [colName, uniqueValues] of Object.entries(window.participantsTsvData)) {
      if (!enrichedData[colName]) {
        // This is a custom column not in NeuroBagel
        const detectedType = window.autoDetectDataType(colName, uniqueValues);
        console.log(`üîç Auto-detected data type for custom column ${colName}:`, detectedType);
        
        enrichedData[colName] = {
          description: `Column: ${colName}`,
          data_type: detectedType,
          standardized_variable: null
        };
        
        // If detected as categorical, add levels from TSV
        if (detectedType === 'categorical') {
          enrichedData[colName].levels = {};
          uniqueValues.forEach(value => {
            enrichedData[colName].levels[value] = {
              label: value,
              description: '',
              uri: null
            };
          });
          console.log(`üìä Custom column ${colName} - added ${uniqueValues.length} categorical levels`);
        }
      }
    }
  } else {
    console.log('‚ÑπÔ∏è No TSV data available - using NeuroBagel defaults only');
  }
  
  // Merge existing participants.json data if available
  if (window.existingParticipantsData) {
    console.log('üîÑ Merging existing participants.json data into widget');
    for (const [colName, colMeta] of Object.entries(window.existingParticipantsData)) {
      if (!enrichedData[colName]) {
        // Add columns that exist in JSON but not in standard NeuroBagel/TSV
        enrichedData[colName] = {
          description: colMeta.Description || '',
          data_type: 'unknown',
          standardized_variable: null
        };
      }
      
      // Update with existing metadata
      if (colMeta.Description) enrichedData[colName].description = colMeta.Description;
      if (colMeta.Units) enrichedData[colName].unit = colMeta.Units;
      
      // NEUROBAGEL ENRICHMENT: Load existing annotations
      if (colMeta.Annotations) {
        if (colMeta.Annotations.IsAbout) {
          enrichedData[colName].term_url = colMeta.Annotations.IsAbout.TermURL;
          enrichedData[colName].label = colMeta.Annotations.IsAbout.Label;
          // Reverse lookup matching concept if possible
          if (colMeta.Annotations.IsAbout.Label) {
              enrichedData[colName].standardized_variable = colMeta.Annotations.IsAbout.Label.toLowerCase();
          }
        }
        if (colMeta.Annotations.VariableType) {
          enrichedData[colName].data_type = colMeta.Annotations.VariableType.toLowerCase();
        }
      }
      
      if (colMeta.Levels) {
        enrichedData[colName].data_type = 'categorical';
        if (!enrichedData[colName].levels) enrichedData[colName].levels = {};
        
        for (const [levelKey, levelLabel] of Object.entries(colMeta.Levels)) {
          if (!enrichedData[colName].levels[levelKey]) {
            enrichedData[colName].levels[levelKey] = {
              label: levelLabel,
              description: '',
              uri: (colMeta.Annotations && colMeta.Annotations.Levels && colMeta.Annotations.Levels[levelKey]) ? colMeta.Annotations.Levels[levelKey].TermURL : null
            };
          } else {
            enrichedData[colName].levels[levelKey].label = levelLabel;
            if (colMeta.Annotations && colMeta.Annotations.Levels && colMeta.Annotations.Levels[levelKey]) {
                enrichedData[colName].levels[levelKey].uri = colMeta.Annotations.Levels[levelKey].TermURL;
            }
          }
        }
      }
    }
  }

  // Reconcile type using current TSV evidence (preview/local), so stale schema text
  // types do not override clear categorical columns like education_level/sleep codes.
  if (window.participantsTsvData) {
    for (const [colName, uniqueValues] of Object.entries(window.participantsTsvData)) {
      if (!enrichedData[colName]) continue;
      const inferred = window.autoDetectDataType(colName, uniqueValues);
      const currentType = (enrichedData[colName].data_type || '').toLowerCase();

      if (inferred === 'categorical' && (currentType === 'text' || currentType === 'string' || currentType === 'unknown' || !currentType)) {
        enrichedData[colName].data_type = 'categorical';
        if (!enrichedData[colName].levels) {
          enrichedData[colName].levels = {};
        }
        uniqueValues.forEach(value => {
          if (!enrichedData[colName].levels[value]) {
            enrichedData[colName].levels[value] = {
              label: value,
              description: '',
              uri: null
            };
          }
        });
      }
    }
  }
  
  window.neurobagelWidgetState.allColumns = enrichedData;
  
  // Categorize columns into AVAILABLE (in TSV) and TO ADD (suggestions)
  const tsvColumns = window.participantsTsvData ? Object.keys(window.participantsTsvData) : [];
  const available = {};  // Columns in the TSV file
  const toAdd = {};      // NeuroBagel suggestions not in TSV
  
  for (const [colName, colData] of Object.entries(enrichedData)) {
    // Case-insensitive match for BIDS columns (e.g., participant_id vs ParticipantID)
    const colNameLower = colName.toLowerCase().replace(/_/g, '');
    const matchedTsvColumn = tsvColumns.find(c => {
        const cLower = c.toLowerCase().replace(/_/g, '');
        return cLower === colNameLower || cLower === colName.toLowerCase();
    });

    if (matchedTsvColumn) {
      available[matchedTsvColumn] = colData;
    } else {
      toAdd[colName] = colData;
    }
  }
  
  console.log('üìä Available columns (in TSV):', Object.keys(available));
  console.log('üìä To Add (NeuroBagel suggestions):', Object.keys(toAdd));
  
  // Render sidebar
  const sidebar = document.getElementById('neurobagelSidebar');
  if (!sidebar) {
    console.error('‚ùå neurobagelSidebar element not found!');
    return;
  }
  sidebar.innerHTML = '';
  
  // AVAILABLE section - split into NeuroBagel harmonized and custom variables
  if (Object.keys(available).length > 0) {
    const availableSection = document.createElement('div');
    availableSection.style.marginBottom = '16px';
    
    const availableTitle = document.createElement('div');
    availableTitle.className = 'nb-section-title';
    availableTitle.style.marginTop = '0';
    availableTitle.textContent = '‚úì Available';
    availableSection.appendChild(availableTitle);
    
    // Separate into harmonized (has standardized_variable) and custom
    const harmonized = {};
    const custom = {};
    
    for (const [colName, colData] of Object.entries(available)) {
      if (colData.standardized_variable) {
        harmonized[colName] = colData;
      } else {
        custom[colName] = colData;
      }
    }
    
    // Render NeuroBagel Harmonized subsection
    if (Object.keys(harmonized).length > 0) {
      const harmonizedSubtitle = document.createElement('div');
      harmonizedSubtitle.style.fontSize = '11px';
      harmonizedSubtitle.style.fontWeight = '600';
      harmonizedSubtitle.style.color = '#0d6efd';
      harmonizedSubtitle.style.marginTop = '8px';
      harmonizedSubtitle.style.marginBottom = '4px';
      harmonizedSubtitle.style.paddingLeft = '4px';
      harmonizedSubtitle.textContent = 'üî∑ NEUROBAGEL HARMONIZED';
      availableSection.appendChild(harmonizedSubtitle);
      
      for (const [colName, colData] of Object.entries(harmonized)) {
        const item = document.createElement('div');
        item.className = 'nb-column-item';
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
            <span>${colName}</span>
            <span class="nb-column-item-type">${colData.data_type}</span>
          </div>
        `;
        item.onclick = () => window.selectNeurobagelColumn(colName);
        availableSection.appendChild(item);
      }
    }
    
    // Render Custom Variables subsection
    if (Object.keys(custom).length > 0) {
      const customSubtitle = document.createElement('div');
      customSubtitle.style.fontSize = '11px';
      customSubtitle.style.fontWeight = '600';
      customSubtitle.style.color = '#6c757d';
      customSubtitle.style.marginTop = '12px';
      customSubtitle.style.marginBottom = '4px';
      customSubtitle.style.paddingLeft = '4px';
      customSubtitle.textContent = 'üìã CUSTOM VARIABLES';
      availableSection.appendChild(customSubtitle);
      
      for (const [colName, colData] of Object.entries(custom)) {
        const item = document.createElement('div');
        item.className = 'nb-column-item';
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
            <span>${colName}</span>
            <span class="nb-column-item-type">${colData.data_type}</span>
          </div>
        `;
        item.onclick = () => window.selectNeurobagelColumn(colName);
        availableSection.appendChild(item);
      }
    }
    
    sidebar.appendChild(availableSection);
  }
  
  // TO ADD section
  if (Object.keys(toAdd).length > 0) {
    const toAddSection = document.createElement('div');
    
    const toAddTitle = document.createElement('div');
    toAddTitle.className = 'nb-section-title';
    toAddTitle.textContent = '+ To Add';
    toAddTitle.style.marginTop = Object.keys(available).length > 0 ? '12px' : '0';
    toAddSection.appendChild(toAddTitle);
    
    for (const [colName, colData] of Object.entries(toAdd)) {
      const item = document.createElement('div');
      item.className = 'nb-column-item';
      item.style.opacity = '0.7';
      item.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
          <span>${colName}</span>
          <span class="nb-column-item-type">${colData.data_type}</span>
        </div>
      `;
      item.onclick = () => window.selectNeurobagelColumn(colName);
      toAddSection.appendChild(item);
    }
    
    sidebar.appendChild(toAddSection);
  }
  
  // Force widget to be visible
  const widgetContent = document.getElementById('neurobagelWidgetContent');
  if (widgetContent) {
    widgetContent.style.display = 'flex';
    console.log('‚úÖ Widget content display set to flex');
  }
  
  console.log('‚úÖ renderNeurobagelWidget completed successfully');
};

window.selectNeurobagelColumn = function(colName) {
  window.neurobagelWidgetState.selectedColumn = colName;
  
  // Update active state
  document.querySelectorAll('.nb-column-item').forEach(item => {
    item.classList.remove('active');
  });
  event.target.closest('.nb-column-item').classList.add('active');
  
  // Render editor
  const colData = window.neurobagelWidgetState.allColumns[colName];
  window.renderNeurobagelEditor(colName, colData);
};

window.renderNeurobagelEditor = function(colName, colData) {
  const editor = document.getElementById('neurobagelEditor');
  const dataType = colData.data_type || 'unknown';
  
  let html = `
    <div class="nb-editor-header">
      <div>
        <div class="nb-editor-title">${colName}</div>
      </div>
      <div>
        <span class="nb-editor-type-badge">${dataType}</span>
        ${colData.standardized_variable ? `<span class="badge bg-success ms-1" style="font-size: 10px;">Enriched: ${colData.standardized_variable}</span>` : ''}
      </div>
    </div>
    
    <!-- Semantic Enrichment Section -->
    <div class="nb-field-group" style="background: #eef7ff; padding: 12px; border-radius: 6px; border: 1px solid #cce5ff; margin-bottom: 20px;">
      <label class="nb-field-label" style="color: #0056b3; display: flex; align-items: center;">
        <i class="fas fa-magic me-2"></i>Semantic Enrichment
      </label>
      <div style="display: flex; gap: 8px; margin-top: 8px;">
        <select class="nb-field-input" id="nb-map-${colName}" style="flex: 1; min-width: 0; padding: 6px; font-size: 13px;">
          <option value="">-- Map to NeuroBagel Concept --</option>
          <optgroup label="Demographics">
            <option value="Sex" ${colData.standardized_variable === 'biological_sex' ? 'selected' : ''}>Sex / Gender</option>
            <option value="Age" ${colData.standardized_variable === 'age' ? 'selected' : ''}>Age</option>
            <option value="Handedness" ${colData.standardized_variable === 'handedness' ? 'selected' : ''}>Handedness</option>
            <option value="Education" ${colData.standardized_variable === 'education' || colData.standardized_variable === 'education_level' ? 'selected' : ''}>Education Level</option>
          </optgroup>
          <optgroup label="Clinical">
            <option value="Diagnosis" ${colData.standardized_variable === 'participant_group' || colData.standardized_variable === 'diagnosis' ? 'selected' : ''}>Diagnosis / Group</option>
            <option value="Assessment" ${colData.standardized_variable === 'assessment' ? 'selected' : ''}>Assessment / Score</option>
          </optgroup>
          <optgroup label="Identifiers">
            <option value="ParticipantID" ${colData.standardized_variable === 'participant_id' ? 'selected' : ''}>Participant ID</option>
            <option value="SessionID" ${colData.standardized_variable === 'session_id' ? 'selected' : ''}>Session ID</option>
          </optgroup>
        </select>
        <button class="nb-btn nb-btn-primary" onclick="window.applyNeurobagelEnrichment('${colName}')" style="padding: 4px 10px;">
          Map
        </button>
      </div>
      ${colData.term_url ? `<div style="margin-top: 6px; font-size: 11px; color: #0056b3;">üîó <code>${colData.term_url}</code></div>` : ''}
    </div>
    
    <!-- Editable Description Field -->
    <div class="nb-field-group">
      <label class="nb-field-label">Description</label>
      <textarea 
        class="nb-field-input" 
        id="nb-desc-${colName}" 
        placeholder="Enter description for this field"
        style="width: 100%; height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
      >${colData.description || ''}</textarea>
    </div>
  `;
  
  if (dataType === 'continuous') {
    // Editable unit field for continuous
    html += `
      <div class="nb-field-group">
        <label class="nb-field-label">Unit</label>
        <input 
          type="text" 
          class="nb-field-input" 
          id="nb-unit-${colName}" 
          placeholder="e.g., years, kg, mm"
          value="${colData.unit || ''}"
          style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
        />
      </div>
    `;
  } else if (dataType === 'categorical' && colData.levels) {
    // Categorical levels with editable descriptions
    html += `
      <div class="nb-field-group">
        <div class="nb-field-label">Categorical Levels</div>
        <div class="nb-value-list">
    `;
    
    for (const [levelKey, levelData] of Object.entries(colData.levels)) {
      const description = levelData.description || '';
      const uniqueId = `nb-cat-${colName}-${levelKey}`;
      
      html += `
        <div class="nb-categorical-item" style="border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-bottom: 8px; background: #fff;">
          <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
            <span style="font-weight: 600; min-width: 60px; padding: 4px 8px; background: #e7f1ff; border-radius: 4px; font-size: 12px;">${levelKey}</span>
            <span style="color: #666; font-size: 12px;">‚Üí</span>
            <input 
              type="text" 
              class="nb-categorical-label" 
              id="${uniqueId}-label" 
              placeholder="Label (e.g., Healthy Controls)"
              value="${levelData.label || levelKey}"
              style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px;"
            />
          </div>
          <textarea 
            class="nb-categorical-desc" 
            id="${uniqueId}-desc" 
            placeholder="Description (e.g., Healthy control group)"
            style="width: 100%; height: 40px; padding: 6px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px;"
          >${description}</textarea>
          ${levelData.uri ? `<div style="margin-top: 6px; font-size: 11px; color: #666;">üîó <code>${levelData.uri}</code></div>` : ''}
        </div>
      `;
    }
    
    html += `
        </div>
      </div>
    `;
  }
  
  html += `
    <div class="nb-button-group">
      <button class="nb-btn nb-btn-primary" onclick="window.applyNeurobagelToForm('${colName}')">
        ‚úì Apply to Form
      </button>
      <button class="nb-btn" onclick="window.copyNeurobagelData('${colName}')">
        üìã Copy
      </button>
    </div>
  `;
  
  editor.innerHTML = html;
  
  // Store edited values back to column data when user changes them
  const descField = document.getElementById(`nb-desc-${colName}`);
  const unitField = document.getElementById(`nb-unit-${colName}`);
  
  if (descField) {
    descField.addEventListener('change', function() {
      colData.description = this.value;
      console.log(`Updated description for ${colName}:`, this.value);
    });
  }
  
  if (unitField) {
    unitField.addEventListener('change', function() {
      colData.unit = this.value;
      console.log(`Updated unit for ${colName}:`, this.value);
    });
  }
  
  // Add listeners for categorical level edits
  if (dataType === 'categorical' && colData.levels) {
    for (const levelKey of Object.keys(colData.levels)) {
      const uniqueId = `nb-cat-${colName}-${levelKey}`;
      const labelField = document.getElementById(`${uniqueId}-label`);
      const descField = document.getElementById(`${uniqueId}-desc`);
      
      if (labelField) {
        labelField.addEventListener('change', function() {
          colData.levels[levelKey].label = this.value || levelKey;
          console.log(`Updated label for ${colName}/${levelKey}:`, this.value);
        });
      }
      
      if (descField) {
        descField.addEventListener('change', function() {
          colData.levels[levelKey].description = this.value;
          console.log(`Updated description for ${colName}/${levelKey}:`, this.value);
        });
      }
    }
  }
};

window.applyNeurobagelLevel = function(colName, levelKey) {
  const colData = window.neurobagelWidgetState.allColumns[colName];
  const levelData = colData.levels[levelKey];
  
  // Find matching form fields and fill with level info
  const selector = `[data-json-path^="${colName}.levels.${levelKey}"]`;
  const matches = Array.from(document.querySelectorAll(selector));
  
  if (matches.length > 0) {
    const suggestion = `${levelData.label || levelKey}\nDescription: ${levelData.description}\nURI: ${levelData.uri || 'N/A'}`;
    matches.forEach(el => { el.value = suggestion; });
    if (typeof showAlert === 'function') {
      showAlert(`Applied ${colName}/${levelKey} level annotation`, 'success');
    }
  }
};

window.applyNeurobagelToForm = function(colName) {
  const colData = window.neurobagelWidgetState.allColumns[colName];
  
  // Find form fields for this column
  const selector = `[data-json-path^="${colName}."]`;
  const matches = Array.from(document.querySelectorAll(selector));
  
  if (matches.length === 0) {
    if (typeof showAlert === 'function') {
      showAlert(`No form fields found for ${colName}`, 'warning');
    }
    return;
  }
  
  // Build comprehensive annotation
  let annotation = `Column: ${colName}\n`;
  annotation += `Type: ${colData.data_type}\n`;
  annotation += `Standardized Variable: ${colData.standardized_variable || 'N/A'}\n`;
  annotation += `Description: ${colData.description || 'N/A'}\n`;
  
  if (colData.data_type === 'categorical' && colData.levels) {
    annotation += `\nCategorical Levels:\n`;
    for (const [k, v] of Object.entries(colData.levels)) {
      annotation += `  ${k}: ${v.label} (${v.uri || 'No URI'})\n`;
    }
  } else if (colData.data_type === 'continuous') {
    annotation += `Unit: ${colData.unit || 'Not specified'}\n`;
  }
  
  // Apply to first textarea
  if (matches.length > 0) {
    matches[0].value = annotation;
  }
  
  if (typeof showAlert === 'function') {
    showAlert(`Applied annotation to ${colName}`, 'success');
  }
  
  // Re-render widget to update sidebar categorization (e.g., custom ‚Üí harmonized)
  window.renderNeurobagelWidget();
};

window.copyNeurobagelData = function(colName) {
  const colData = window.neurobagelWidgetState.allColumns[colName];
  const json = JSON.stringify(colData, null, 2);
  
  navigator.clipboard.writeText(json).then(() => {
    if (typeof showAlert === 'function') {
      showAlert(`Copied ${colName} data to clipboard`, 'success');
    }
  });
};

// Initialize widget when NeuroBagel data loads
document.addEventListener('DOMContentLoaded', async function() {
  // Wait for NeuroBagel data to be available
  await new Promise(resolve => setTimeout(resolve, 1000));
  await window.renderNeurobagelWidget();
  document.getElementById('neurobagelAnnotationWidget').style.display = 'block';
});
</script>
